<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D 梦幻星系树 - 辉光交互版</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #ui-overlay { position: absolute; top: 30px; left: 30px; color: white; z-index: 20; pointer-events: none; text-shadow: 0 0 10px rgba(0,0,0,0.5); }
        #video-container { position: absolute; bottom: 20px; right: 20px; width: 120px; height: 90px; border-radius: 8px; overflow: hidden; border: 1px solid rgba(255,255,255,0.3); z-index: 10; transform: scaleX(-1); opacity: 0.8; }
        #fallback-btn { position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%); padding: 15px 35px; background: rgba(255,255,255,0.15); border: 1px solid rgba(255,255,255,0.5); color: white; border-radius: 50px; cursor: pointer; backdrop-filter: blur(10px); z-index: 100; font-weight: bold; transition: all 0.3s; }
        #fallback-btn:active { transform: translateX(-50%) scale(0.9); background: rgba(255,255,255,0.3); }
    </style>
</head>
<body>

<div id="ui-overlay">
    <h2 style="margin:0; letter-spacing: 2px;">NEON XMAS GALAXY</h2>
    <div id="status-text" style="font-size: 14px; color: #ffd700; margin-top: 5px;">模式: 圣诞树 (准备就绪)</div>
</div>

<div id="video-container"><video id="input_video" playsinline muted autoplay></video></div>
<button id="fallback-btn">点击屏幕或此处切换形态</button>
<div id="canvas-container"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/ShaderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/shaders/CopyShader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/shaders/LuminosityHighPassShader.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script type="module">
// 使用 Module 模式以便导入扩展组件
import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';

let scene, camera, renderer, composer, particles, photoGroup, star;
let particlePositions = { tree: [], galaxy: [] };
let photoData = [];
let isTree = true;
const P_COUNT = 10000;

// 初始化
function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 40;

    renderer = new THREE.WebGLRenderer({ antialias: false }); // Bloom 下关闭原生抗锯齿以提升性能
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ReinhardToneMapping;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // --- 后期特效配置 (Bloom) ---
    const renderScene = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloomPass.threshold = 0.2; // 亮度阈值
    bloomPass.strength = 1.8;  // 辉光强度
    bloomPass.radius = 0.5;    // 散射半径

    composer = new EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    setupShapes();
    createParticles();
    createPhotos();
    createStar();
    setupHandTracking();
    animate();
}

function setupShapes() {
    for (let i = 0; i < P_COUNT; i++) {
        // Tree: 螺旋分层树
        const layer = Math.random() * 25; 
        const angle = i * 0.2;
        const radius = (25 - layer) * 0.4;
        particlePositions.tree.push(radius * Math.cos(angle), layer - 12, radius * Math.sin(angle));

        // Galaxy: 旋涡星系
        const gRadius = Math.random() * 30;
        const gAngle = gRadius * 0.8;
        particlePositions.galaxy.push(
            Math.cos(gAngle) * gRadius + (Math.random()-0.5)*5,
            (Math.random()-0.5) * (15 / (gRadius + 1)),
            Math.sin(gAngle) * gRadius + (Math.random()-0.5)*5
        );
    }
}

function createParticles() {
    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.Float32BufferAttribute(particlePositions.tree, 3));
    
    const colors = [];
    const colorPalette = [new THREE.Color(0xffd700), new THREE.Color(0xff2200), new THREE.Color(0x00ff66), new THREE.Color(0xffffff)];
    for(let i=0; i<P_COUNT; i++) {
        const c = colorPalette[Math.floor(Math.random()*4)];
        colors.push(c.r, c.g, c.b);
    }
    geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

    const mat = new THREE.PointsMaterial({ size: 0.15, vertexColors: true, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
    particles = new THREE.Points(geo, mat);
    scene.add(particles);
}

function createPhotos() {
    photoGroup = new THREE.Group();
    const loader = new THREE.TextureLoader();
    for(let i=0; i<40; i++) {
        const tex = loader.load(`https://picsum.photos/200?random=${i}`);
        const mesh = new THREE.Mesh(
            new THREE.PlaneGeometry(1.5, 1.5), 
            new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 0.9, side: THREE.DoubleSide })
        );
        const idx = Math.floor(Math.random() * P_COUNT) * 3;
        mesh.position.set(particlePositions.tree[idx], particlePositions.tree[idx+1], particlePositions.tree[idx+2]);
        photoData.push({ mesh, idx });
        photoGroup.add(mesh);
    }
    scene.add(photoGroup);
}

function createStar() {
    const starShape = new THREE.Shape();
    for(let i=0; i<10; i++){
        const r = i%2==0 ? 2 : 0.8;
        const a = i/10 * Math.PI*2;
        if(i==0) starShape.moveTo(Math.cos(a)*r, Math.sin(a)*r);
        else starShape.lineTo(Math.cos(a)*r, Math.sin(a)*r);
    }
    star = new THREE.Mesh(new THREE.ExtrudeGeometry(starShape, {depth:0.2}), new THREE.MeshBasicMaterial({color:0xfff000}));
    star.position.y = 13.5;
    scene.add(star);
}

// 核心：形态转换
function toggleMorph() {
    isTree = !isTree;
    const targetArr = isTree ? particlePositions.tree : particlePositions.galaxy;
    const status = document.getElementById('status-text');
    status.innerText = isTree ? "模式: 圣诞树" : "模式: 梦幻星系";

    // 粒子变换
    gsap.to(particles.geometry.attributes.position.array, {
        duration: 2.5,
        endArray: targetArr,
        ease: "expo.inOut",
        onUpdate: () => particles.geometry.attributes.position.needsUpdate = true
    });

    // 照片变换
    photoData.forEach(item => {
        gsap.to(item.mesh.position, {
            duration: 2.5,
            x: targetArr[item.idx],
            y: targetArr[item.idx+1],
            z: targetArr[item.idx+2],
            ease: "expo.inOut"
        });
    });

    // 树顶星淡入淡出
    gsap.to(star.scale, { duration: 1, x: isTree?1:0, y: isTree?1:0, z: isTree?1:0 });
}

// 手势逻辑
function setupHandTracking() {
    const hands = new window.Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
    hands.setOptions({ modelComplexity: 0, minDetectionConfidence: 0.5 });
    hands.onResults(res => {
        if(res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
            const hand = res.multiHandLandmarks[0];
            const isOpen = Math.hypot(hand[8].x - hand[0].x, hand[8].y - hand[0].y) > 0.4;
            if(isOpen && isTree) toggleMorph();
            if(!isOpen && !isTree) toggleMorph();
            // 随手势旋转
            particles.rotation.y += (hand[0].x - 0.5) * 0.05;
            photoGroup.rotation.y += (hand[0].x - 0.5) * 0.05;
        }
    });
    const cam = new window.Camera(document.getElementById('input_video'), {
        onFrame: async () => { await hands.send({image: document.getElementById('input_video')}); },
        width: 640, height: 480
    });
    cam.start().catch(() => console.log("Camera blocked"));
}

function animate() {
    requestAnimationFrame(animate);
    particles.rotation.y += 0.002;
    photoGroup.rotation.y += 0.002;
    // 照片始终朝向相机
    photoGroup.children.forEach(p => p.lookAt(camera.position));
    composer.render(); // 使用 composer 代替 renderer
}

// 绑定交互：点击屏幕任意位置或按钮
window.addEventListener('mousedown', (e) => {
    if(e.target.tagName !== 'BUTTON') toggleMorph();
});
document.getElementById('fallback-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    toggleMorph();
});

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
});

init();
</script>
</body>
</html>