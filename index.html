<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D 深度星系圣诞树</title>
    <style>
        body { margin: 0; background: #00050a; overflow: hidden; font-family: -apple-system, sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        /* 确保视频可见 */
        #video-container { 
            position: absolute; bottom: 20px; left: 20px; 
            width: 140px; height: 105px; 
            border-radius: 12px; overflow: hidden; 
            border: 2px solid rgba(255,255,255,0.4); 
            z-index: 1000; transform: scaleX(-1);
            background: #111;
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        #ui-overlay { position: absolute; top: 25px; left: 25px; color: white; z-index: 20; pointer-events: none; }
        .hint { font-size: 13px; color: #00d4ff; margin-top: 5px; text-shadow: 0 0 5px rgba(0,212,255,0.5); }
        #control-btn { 
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            padding: 14px 28px; background: rgba(0, 212, 255, 0.2); 
            border: 1px solid #00d4ff; color: white; border-radius: 50px; 
            cursor: pointer; z-index: 1001; backdrop-filter: blur(8px);
            font-weight: bold; transition: 0.3s;
        }
        #control-btn:hover { background: rgba(0, 212, 255, 0.4); }
    </style>
</head>
<body>

<div id="ui-overlay">
    <h2 style="margin:0; letter-spacing: 1px;">GALAXY MORPH v3.0</h2>
    <div id="gesture-status" class="hint">摄像头初始化中...</div>
</div>

<div id="video-container">
    <video id="input_video" playsinline autoplay muted></video>
</div>

<button id="control-btn">点击手动变换形态</button>
<div id="canvas-container"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
let scene, camera, renderer, particles, photoGroup, star;
let isTree = true;
const P_COUNT = 9000;
const positions = { tree: new Float32Array(P_COUNT * 3), galaxy: new Float32Array(P_COUNT * 3) };
const photoData = [];

function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 40);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    generateShapes();
    createParticleSystem();
    createPhotos();
    createStar();
    setupMediaPipe();
    animate();
}

function generateShapes() {
    for (let i = 0; i < P_COUNT; i++) {
        // 1. 圣诞树形态 (分段螺旋锥体)
        const y = Math.random() * 28 - 14;
        const section = Math.floor((y + 14) / 7); // 树的分层感
        const radius = (14 - y) * 0.4 + (Math.random() * 0.5);
        const angle = i * 0.12 + (section * Math.PI / 2);
        positions.tree[i*3] = radius * Math.cos(angle);
        positions.tree[i*3+1] = y;
        positions.tree[i*3+2] = radius * Math.sin(angle);

        // 2. 星系形态 (对数螺旋算法 - 效果展开核心)
        const branch = i % 3; // 三旋臂
        const r = Math.random() * 32;
        const theta = r * 0.5 + (branch * (Math.PI * 2 / 3)); 
        const spread = (Math.random() - 0.5) * (4 / (r * 0.1 + 1));
        positions.galaxy[i*3] = Math.cos(theta) * r + spread;
        positions.galaxy[i*3+1] = (Math.random() - 0.5) * 5 * (1 - r/35);
        positions.galaxy[i*3+2] = Math.sin(theta) * r + spread;
    }
}

function createParticleSystem() {
    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions.tree), 3));
    
    const colors = new Float32Array(P_COUNT * 3);
    const colorOptions = [new THREE.Color(0xffd700), new THREE.Color(0x00ffcc), new THREE.Color(0xff3366), new THREE.Color(0xffffff)];
    for(let i=0; i<P_COUNT; i++) {
        const c = colorOptions[Math.floor(Math.random() * 4)];
        c.toArray(colors, i*3);
    }
    geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const mat = new THREE.PointsMaterial({
        size: 0.18,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        transparent: true,
        opacity: 0.8
    });

    particles = new THREE.Points(geo, mat);
    scene.add(particles);
}

function createPhotos() {
    photoGroup = new THREE.Group();
    const loader = new THREE.TextureLoader();
    for(let i=0; i<45; i++) {
        const url = `https://picsum.photos/200?random=${i}`;
        const mat = new THREE.MeshBasicMaterial({ 
            map: loader.load(url), 
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.9
        });
        const mesh = new THREE.Mesh(new THREE.PlaneGeometry(1.6, 1.6), mat);
        
        const pIdx = Math.floor(Math.random() * P_COUNT);
        mesh.position.set(positions.tree[pIdx*3], positions.tree[pIdx*3+1], positions.tree[pIdx*3+2]);
        
        photoData.push({ mesh, pIdx, rand: Math.random() * 10 });
        photoGroup.add(mesh);
    }
    scene.add(photoGroup);
}

function createStar() {
    const shape = new THREE.Shape();
    for(let i=0; i<10; i++) {
        const r = i % 2 === 0 ? 2.8 : 1.2;
        const a = (i / 10) * Math.PI * 2;
        if(i === 0) shape.moveTo(Math.cos(a)*r, Math.sin(a)*r);
        else shape.lineTo(Math.cos(a)*r, Math.sin(a)*r);
    }
    star = new THREE.Mesh(new THREE.ShapeGeometry(shape), new THREE.MeshBasicMaterial({ color: 0xffd700 }));
    star.position.y = 15;
    scene.add(star);
}

function toggle() {
    isTree = !isTree;
    const target = isTree ? positions.tree : positions.galaxy;
    document.getElementById('gesture-status').innerText = isTree ? "模式: 圣诞树" : "模式: 深度星系";

    // 粒子变换
    gsap.to(particles.geometry.attributes.position.array, {
        duration: 2.2,
        endArray: target,
        ease: "expo.inOut",
        onUpdate: () => particles.geometry.attributes.position.needsUpdate = true
    });

    // 照片变换
    photoData.forEach(p => {
        gsap.to(p.mesh.position, {
            duration: 2.5,
            x: target[p.pIdx*3],
            y: target[p.pIdx*3+1],
            z: target[p.pIdx*3+2],
            ease: "expo.inOut"
        });
    });

    // 星星
    gsap.to(star.scale, { duration: 1, x: isTree?1:0, y: isTree?1:0 });
}

function setupMediaPipe() {
    const video = document.getElementById('input_video');
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    
    hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.6 });
    
    hands.onResults(results => {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const h = results.multiHandLandmarks[0];
            const isFist = Math.hypot(h[8].x - h[0].x, h[8].y - h[0].y) < 0.25;
            
            if (isFist && !isTree) toggle();
            else if (!isFist && isTree) toggle();

            // 联动旋转
            particles.rotation.y += (h[0].x - 0.5) * 0.08;
            photoGroup.rotation.y += (h[0].x - 0.5) * 0.08;
            document.getElementById('gesture-status').innerText = isFist ? "手势: 握拳 (聚集成树)" : "手势: 张开 (展开星系)";
        }
    });

    const cameraProvider = new Camera(video, {
        onFrame: async () => { await hands.send({image: video}); },
        width: 640, height: 480
    });
    cameraProvider.start().then(() => {
        document.getElementById('gesture-status').innerText = "摄像头已就绪";
    });
}

function animate() {
    requestAnimationFrame(animate);
    const time = Date.now() * 0.001;

    particles.rotation.y += 0.002;
    photoGroup.rotation.y += 0.002;

    photoData.forEach(p => {
        // 微小的浮动感
        p.mesh.position.y += Math.sin(time + p.rand) * 0.01;
        p.mesh.lookAt(camera.position);
    });

    renderer.render(scene, camera);
}

// 交互
document.getElementById('control-btn').onclick = (e) => { e.stopPropagation(); toggle(); };
window.onclick = () => toggle();
window.onresize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
};

init();
</script>
</body>
</html>