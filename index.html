<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D 梦幻粒子星系 - 修复增强版</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #ui-overlay { position: absolute; top: 20px; left: 20px; color: white; z-index: 20; pointer-events: none; }
        #fallback-btn { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
                        padding: 12px 25px; background: rgba(255,255,255,0.2); border: 1px solid #fff;
                        color: white; border-radius: 30px; cursor: pointer; z-index: 100; backdrop-filter: blur(5px); }
        #video-container { position: absolute; bottom: 10px; right: 10px; width: 120px; height: 90px; 
                           border-radius: 8px; overflow: hidden; opacity: 0.5; transform: scaleX(-1); }
    </style>
</head>
<body>

<div id="ui-overlay">
    <h3 style="margin:0;">GLOWING PARTICLES</h3>
    <div id="status">状态: 圣诞树模式 (点击屏幕切换)</div>
</div>

<div id="video-container"><video id="input_video" playsinline muted autoplay></video></div>
<button id="fallback-btn">手动切换形态</button>
<div id="canvas-container"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/**
 * 基础变量
 */
let scene, camera, renderer, particles, photos = [], star;
let isTree = true;
const P_COUNT = 8000;
const treePos = new Float32Array(P_COUNT * 3);
const galaxyPos = new Float32Array(P_COUNT * 3);

/**
 * 核心：初始化场景
 */
function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 45;

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    createShapes();
    createParticleSystem();
    createPhotos();
    createStar();
    initMediaPipe();
    animate();
}

/**
 * 形状算法：预计算圣诞树和星系的位置
 */
function createShapes() {
    for (let i = 0; i < P_COUNT; i++) {
        // 1. 圣诞树 (螺旋锥体层级)
        const y = Math.random() * 30 - 15;
        const radius = (15 - y) * 0.4;
        const angle = i * 0.15;
        treePos[i*3] = radius * Math.cos(angle);
        treePos[i*3+1] = y;
        treePos[i*3+2] = radius * Math.sin(angle);

        // 2. 星系 (黄金螺旋)
        const gRadius = Math.random() * 35;
        const gAngle = gRadius * 0.6;
        galaxyPos[i*3] = Math.cos(gAngle) * gRadius + (Math.random()-0.5)*3;
        galaxyPos[i*3+1] = (Math.random()-0.5) * (20 / (gRadius + 1));
        galaxyPos[i*3+2] = Math.sin(gAngle) * gRadius + (Math.random()-0.5)*3;
    }
}

function createParticleSystem() {
    const geo = new THREE.BufferGeometry();
    // 初始设为圣诞树位置
    geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(treePos), 3));
    
    // 颜色混合
    const colors = new Float32Array(P_COUNT * 3);
    const palette = [new THREE.Color(0xffd700), new THREE.Color(0xff4444), new THREE.Color(0x44ffaa)];
    for(let i=0; i<P_COUNT; i++) {
        const c = palette[Math.floor(Math.random()*3)];
        c.toArray(colors, i*3);
    }
    geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const mat = new THREE.PointsMaterial({
        size: 0.18,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        transparent: true,
        opacity: 0.8
    });

    particles = new THREE.Points(geo, mat);
    scene.add(particles);
}

function createPhotos() {
    const loader = new THREE.TextureLoader();
    for(let i=0; i<35; i++) {
        const tex = loader.load(`https://picsum.photos/200?random=${i}`);
        const mesh = new THREE.Mesh(
            new THREE.PlaneGeometry(1.8, 1.8),
            new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide, transparent: true })
        );
        // 随机锚定到一个粒子的索引上
        const pIdx = Math.floor(Math.random() * P_COUNT);
        mesh.position.set(treePos[pIdx*3], treePos[pIdx*3+1], treePos[pIdx*3+2]);
        
        photos.push({ mesh, pIdx });
        scene.add(mesh);
    }
}

function createStar() {
    const shape = new THREE.Shape();
    for(let i=0; i<10; i++) {
        const r = i%2==0 ? 2.5 : 1;
        const a = i/10 * Math.PI*2;
        if(i==0) shape.moveTo(Math.cos(a)*r, Math.sin(a)*r);
        else shape.lineTo(Math.cos(a)*r, Math.sin(a)*r);
    }
    star = new THREE.Mesh(new THREE.ShapeGeometry(shape), new THREE.MeshBasicMaterial({color: 0xffd700}));
    star.position.y = 16;
    scene.add(star);
}

/**
 * 形态切换函数 (Fix: 确保更新 BufferAttribute)
 */
function toggleMorph() {
    isTree = !isTree;
    const target = isTree ? treePos : galaxyPos;
    document.getElementById('status').innerText = isTree ? "状态: 圣诞树模式" : "状态: 星系模式";

    // 粒子动画
    const posAttr = particles.geometry.attributes.position;
    gsap.to(posAttr.array, {
        duration: 2,
        endArray: target,
        ease: "power2.inOut",
        onUpdate: () => posAttr.needsUpdate = true
    });

    // 照片随动
    photos.forEach(p => {
        gsap.to(p.mesh.position, {
            duration: 2,
            x: target[p.pIdx*3],
            y: target[p.pIdx*3+1],
            z: target[p.pIdx*3+2],
            ease: "power2.inOut"
        });
    });

    // 树顶星动画
    gsap.to(star.scale, { duration: 1, x: isTree?1:0, y: isTree?1:0 });
}

/**
 * 手势与渲染循环
 */
function initMediaPipe() {
    const video = document.getElementById('input_video');
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ modelComplexity: 0 });
    hands.onResults(res => {
        if(res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
            const h = res.multiHandLandmarks[0];
            const dist = Math.hypot(h[8].x - h[0].x, h[8].y - h[0].y);
            if(dist > 0.4 && isTree) toggleMorph();
            if(dist < 0.25 && !isTree) toggleMorph();
            // 实时旋转驱动
            particles.rotation.y += (h[0].x - 0.5) * 0.05;
        }
    });
    const cam = new Camera(video, { onFrame: async() => await hands.send({image: video}), width: 640, height: 480 });
    cam.start().catch(() => console.log("Camera fail"));
}

function animate() {
    requestAnimationFrame(animate);
    const time = Date.now() * 0.0005;
    
    particles.rotation.y += 0.003;
    // 照片始终面向相机
    photos.forEach(p => {
        p.mesh.rotation.y = particles.rotation.y;
        p.mesh.lookAt(camera.position);
    });

    renderer.render(scene, camera);
}

// 绑定交互
window.addEventListener('click', (e) => {
    if(e.target.id !== 'fallback-btn') toggleMorph();
});
document.getElementById('fallback-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    toggleMorph();
});

window.onresize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
};

init();
</script>
</body>
</html>