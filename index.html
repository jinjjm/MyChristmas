<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D æ·±åº¦æ˜Ÿç³»åœ£è¯æ ‘ - æ‰‹åŠ¿ç¨³å®šç‰ˆ</title>
    <style>
        body { margin: 0; background: #00050a; overflow: hidden; font-family: -apple-system, sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #video-container { 
            position: absolute; bottom: 20px; left: 20px; 
            width: 140px; height: 105px; 
            border-radius: 12px; overflow: hidden; 
            border: 2px solid rgba(255,255,255,0.4); 
            z-index: 1000; transform: scaleX(-1);
            background: #111;
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        #ui-overlay { position: absolute; top: 25px; left: 25px; color: white; z-index: 20; pointer-events: none; }
        .hint { font-size: 13px; color: #ffd700; margin-top: 5px; text-shadow: 0 0 5px rgba(255,215,0,0.5); padding: 5px 10px; background: rgba(0,0,0,0.6); border-radius: 5px; }
        #start-mask {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #00050a; z-index: 9999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; cursor: pointer; text-align: center;
        }
        #start-btn {
            padding: 15px 40px; font-size: 20px; background: linear-gradient(135deg, #ffd700, #ff6b6b);
            border: none; border-radius: 30px; color: white; cursor: pointer; font-weight: bold;
        }
    </style>
</head>
<body>

<div id="start-mask" onclick="startExperience()">
    <h1 style="margin-bottom:10px; font-weight:300; letter-spacing:3px;">GALAXY TREE</h1>
    <button id="start-btn">å¼€å¯åœ£è¯ç©ºé—´</button>
</div>

<audio id="bg-music" loop>
    <source src="https://mdn.github.io/learning-area/javascript/apis/video-audio/finished/audio/viper.mp3" type="audio/mpeg">
</audio>

<div id="ui-overlay">
    <h2 style="margin:0; letter-spacing: 3px; font-size: 35px; font-weight: 300; 
               background: linear-gradient(135deg, #ffd700 0%, #ff6b6b 50%, #4ecdc4 100%);
               -webkit-background-clip: text; -webkit-text-fill-color: transparent;
               background-clip: text; font-family: 'Georgia', serif; text-transform: uppercase;">Merry Christmas</h2>
    <div id="gesture-status" class="hint">ç­‰å¾…åŠ è½½åº“æ–‡ä»¶...</div>
</div>

<div id="video-container">
    <video id="input_video" playsinline autoplay muted></video>
</div>

<div id="canvas-container"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
let scene, camera, renderer, particles, photoGroup, star;
let isTree = true;
let currentHandState = "IDLE"; 
const P_COUNT = 9000;
const positions = { tree: new Float32Array(P_COUNT * 3), galaxy: new Float32Array(P_COUNT * 3) };
const photoData = [];
let selectedPhoto = null;
let lastToggleTime = 0;

function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(0, 0, 45); 

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    generateShapes();
    createParticleSystem();
    createPhotos();
    createStar();
    animate();
}

function generateShapes() {
    for (let i = 0; i < P_COUNT; i++) {
        const yTree = Math.random() * 26 - 13;
        const radiusTree = (13 - yTree) * 0.35 + (Math.random() * 0.4);
        const angleTree = i * 0.12;
        positions.tree[i*3] = radiusTree * Math.cos(angleTree);
        positions.tree[i*3+1] = yTree;
        positions.tree[i*3+2] = radiusTree * Math.sin(angleTree);

        const r = Math.random() * 75; 
        const theta = r * 0.3 + (i % 3 * (Math.PI * 2 / 3)); 
        positions.galaxy[i*3] = Math.cos(theta) * r + (Math.random()-0.5)*3;
        positions.galaxy[i*3+1] = (Math.random() - 0.5) * 45 * (1 - r/90); 
        positions.galaxy[i*3+2] = Math.sin(theta) * r + (Math.random()-0.5)*3;
    }
}

function createParticleSystem() {
    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions.tree), 3));
    const colors = new Float32Array(P_COUNT * 3);
    const colorOptions = [new THREE.Color(0xffd700), new THREE.Color(0x00ffcc), new THREE.Color(0xffffff)];
    for(let i=0; i<P_COUNT; i++) colorOptions[i%3].toArray(colors, i*3);
    geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    particles = new THREE.Points(geo, new THREE.PointsMaterial({ size: 0.18, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.8 }));
    scene.add(particles);
}

function createPhotos() {
    photoGroup = new THREE.Group();
    const loader = new THREE.TextureLoader();
    for(let i=0; i<40; i++) {
        const mat = new THREE.MeshBasicMaterial({ map: loader.load(`https://picsum.photos/200?random=${i}`), side: THREE.DoubleSide, transparent: true });
        const mesh = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 1.2), mat);
        
        let pIdx;
        do {
            pIdx = Math.floor(Math.random() * P_COUNT);
        } while (positions.tree[pIdx*3+1] > 10); 

        mesh.position.set(positions.tree[pIdx*3], positions.tree[pIdx*3+1], positions.tree[pIdx*3+2]);
        photoData.push({ mesh, pIdx, rand: Math.random() * 10 });
        photoGroup.add(mesh);
    }
    scene.add(photoGroup);
}

function createStar() {
    const shape = new THREE.Shape();
    for(let i=0; i<10; i++) {
        const r = i % 2 === 0 ? 2.5 : 1.1;
        const a = (i / 10) * Math.PI * 2;
        if(i === 0) shape.moveTo(Math.cos(a)*r, Math.sin(a)*r);
        else shape.lineTo(Math.cos(a)*r, Math.sin(a)*r);
    }
    star = new THREE.Mesh(new THREE.ShapeGeometry(shape), new THREE.MeshBasicMaterial({ color: 0xffd700 }));
    star.position.y = 16.5; 
    scene.add(star);
}

function zoomIn(photo) {
    if (!photo || currentHandState !== "IDLE") return;
    currentHandState = "ANIMATING"; // é˜²æ­¢åŠ¨ç”»ä¸­é‡å¤è§¦å‘
    selectedPhoto = photo;

    photo.oldPos = photo.mesh.position.clone();
    photo.oldScale = photo.mesh.scale.clone();
    photo.oldRot = photo.mesh.rotation.clone();

    scene.attach(photo.mesh); 

    const targetPos = new THREE.Vector3(0, 0, -15);
    targetPos.applyQuaternion(camera.quaternion);
    targetPos.add(camera.position);

    gsap.to(photo.mesh.position, { 
        duration: 0.8, x: targetPos.x, y: targetPos.y, z: targetPos.z, ease: "back.out(1.2)",
        onComplete: () => { currentHandState = "ZOOMED"; }
    });
    gsap.to(photo.mesh.scale, { duration: 0.8, x: 12, y: 12, z: 12, ease: "back.out(1.2)" });
    
    photo.mesh.material.depthTest = false;
    photo.mesh.renderOrder = 9999;
}

function zoomOut() {
    if (!selectedPhoto || currentHandState !== "ZOOMED") return;
    const p = selectedPhoto;
    currentHandState = "ANIMATING";

    photoGroup.attach(p.mesh);

    gsap.to(p.mesh.position, { duration: 0.7, x: p.oldPos.x, y: p.oldPos.y, z: p.oldPos.z, ease: "power2.inOut" });
    gsap.to(p.mesh.scale, { duration: 0.7, x: p.oldScale.x, y: p.oldScale.y, z: p.oldScale.z, ease: "power2.inOut" });
    gsap.to(p.mesh.rotation, { 
        duration: 0.7, x: p.oldRot.x, y: p.oldRot.y, z: p.oldRot.z, ease: "power2.inOut",
        onComplete: () => {
            p.mesh.material.depthTest = true;
            p.mesh.renderOrder = 0;
            selectedPhoto = null;
            currentHandState = "IDLE";
        }
    });
}

function setupMediaPipe() {
    const video = document.getElementById('input_video');
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.75 });
    
    hands.onResults(results => {
        const statusDiv = document.getElementById('gesture-status');
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // æåˆåˆ¤æ–­ (é£ŸæŒ‡ä¸æ‹‡æŒ‡è·ç¦»)
            const pinchDist = Math.hypot(landmarks[8].x - landmarks[4].x, landmarks[8].y - landmarks[4].y);
            const isPinching = pinchDist < 0.04; 
            
            // å¼ å¼€æ‰‹åˆ¤æ–­ (å¤šæŒ‡ä¼¸ç›´)
            const isOpen = landmarks[8].y < landmarks[6].y && landmarks[12].y < landmarks[10].y && pinchDist > 0.15;
            
            // æ¡æ‹³åˆ¤æ–­ (åˆ‡æ¢æ¨¡å¼)
            const isFist = Math.hypot(landmarks[8].x - landmarks[0].x, landmarks[8].y - landmarks[0].y) < 0.22;

            // æ¨¡å¼åˆ‡æ¢é€»è¾‘
            if (currentHandState === "IDLE" && (Date.now() - lastToggleTime > 1500)) {
                if (isFist && !isTree) { toggleMode(true); lastToggleTime = Date.now(); }
                else if (isOpen && isTree) { toggleMode(false); lastToggleTime = Date.now(); }
            }

            // äº¤äº’é€»è¾‘
            if (!isTree) {
                if (currentHandState === "IDLE") {
                    if (isPinching) {
                        // å¯»æ‰¾è·ç¦»å±å¹•ä¸­å¿ƒæœ€è¿‘çš„å›¾ç‰‡
                        let closest = null, minDist = Infinity;
                        photoData.forEach(p => {
                            const v = p.mesh.position.clone().applyMatrix4(photoGroup.matrixWorld); 
                            v.project(camera);
                            const d = Math.hypot(v.x, v.y); 
                            if (d < minDist) { minDist = d; closest = p; }
                        });
                        if(closest) zoomIn(closest);
                    } else {
                        // æœªæ“ä½œæ—¶éšæ‰‹éƒ¨è½¬åŠ¨
                        particles.rotation.y += (landmarks[0].x - 0.5) * 0.04;
                        photoGroup.rotation.y += (landmarks[0].x - 0.5) * 0.04;
                    }
                } else if (currentHandState === "ZOOMED" && isOpen) {
                    // åªæœ‰æ˜ç¡®å¼ å¼€æ‰‹æ‰ç¼©å°
                    zoomOut();
                }
            } else {
                particles.rotation.y += (landmarks[0].x - 0.5) * 0.06;
                photoGroup.rotation.y += (landmarks[0].x - 0.5) * 0.06;
            }

            // æ›´æ–° UI æç¤º
            if (currentHandState === "ZOOMED") {
                statusDiv.innerText = "âœ¨ å·²èšç„¦ç…§ç‰‡ | å¼ å¼€æ‰‹æŒè¿”å›æ˜Ÿç³»";
            } else {
                statusDiv.innerText = isTree ? "ğŸ„ åœ£è¯æ ‘æ¨¡å¼ | å¼ å¼€æ‰‹åˆ‡æ¢æ˜Ÿç³»" : "ğŸŒŒ æ˜Ÿç³»æ¨¡å¼ | æåˆæŒ‡å°–æ‹¾å–ç…§ç‰‡";
            }
        } else {
            // ä¸¢å¤±æ‰‹åŠ¿æ—¶ä¸è‡ªåŠ¨è¿”å›ï¼Œä¿æŒèšç„¦ï¼Œé™¤éæƒ³è‡ªåŠ¨è¿”å›å¯å–æ¶ˆä¸‹é¢æ³¨é‡Š
            // if (currentHandState === "ZOOMED") zoomOut();
            statusDiv.innerText = "è¯·å°†æ‰‹éƒ¨å¯¹å‡†æ‘„åƒå¤´";
        }
    });

    const cameraProv = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 640, height: 480 });
    cameraProv.start();
}

function toggleMode(toTree) {
    isTree = toTree;
    const target = isTree ? positions.tree : positions.galaxy;
    
    const music = document.getElementById('bg-music');
    if (music) {
        gsap.to(music, { playbackRate: isTree ? 1.0 : 0.85, duration: 2 });
    }

    gsap.to(camera.position, { duration: 2, z: isTree ? 45 : 75 }); 
    gsap.to(particles.geometry.attributes.position.array, {
        duration: 2.2, endArray: target, ease: "expo.inOut",
        onUpdate: () => particles.geometry.attributes.position.needsUpdate = true
    });

    photoData.forEach(p => {
        if(p.mesh.parent === photoGroup) {
            gsap.to(p.mesh.position, { duration: 2.2, x: target[p.pIdx*3], y: target[p.pIdx*3+1], z: target[p.pIdx*3+2], ease: "expo.inOut" });
        }
        gsap.to(p.mesh.scale, { duration: 2, x: isTree?1:1.8, y: isTree?1:1.8, z: 1 });
    });
    
    gsap.to(star.scale, { duration: 1, x: isTree?1:0, y: isTree?1:0 });
}

function animate() {
    requestAnimationFrame(animate);
    if (currentHandState === "IDLE") {
        particles.rotation.y += 0.0015;
        photoGroup.rotation.y += 0.0015;
        photoData.forEach(p => {
            p.mesh.position.y += Math.sin(Date.now()*0.001 + p.rand) * 0.01;
            p.mesh.lookAt(camera.position);
        });
    } else if (selectedPhoto) {
        selectedPhoto.mesh.quaternion.copy(camera.quaternion);
    }
    renderer.render(scene, camera);
}

function startExperience() {
    document.getElementById('start-mask').style.display = 'none';
    const music = document.getElementById('bg-music');
    if (music) {
        music.volume = 0;
        music.play().catch(e => console.log("Audio play failed", e));
        gsap.to(music, { volume: 0.4, duration: 3 });
    }
    init();
    setupMediaPipe();
}

window.onresize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
};
</script>
</body>
</html>